---
output: 
  beamer_presentation:
    keep_tex: true
    fig_crop: no
    theme: 'default'
    colortheme: 'beaver'
    includes:
      in_header: 
        - page_headers.tex
header-includes:
- \usepackage{setspace}
- \usepackage{float}
- \usepackage{mathtools}
- \usepackage{natbib}
- \usepackage[linesnumbered,ruled,vlined]{algorithm2e} 
- \setcitestyle{numbers,square,comma}
- \usepackage{verbatim}
- \usepackage{amsthm}
- \usepackage{comment}
- \usepackage{graphicx}
- \setbeamertemplate{itemize items}[circle]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      comment = NA, 
                      warning = FALSE, 
                      message = FALSE,
                      fig.align = 'center',
                      fig.lp = '')
options(xtable.comment = FALSE, 
        xtable.table.placement = 'H')
library(ggplot2)
import::from(magrittr, `%>%`)
theme_set(theme_bw())

source('~/dev/pabm-grdpg/functions.R')
set.seed(314159)
```

## {.plain}

\center

\LARGE

\textcolor{darkred}{Popularity Adjusted Block Models are Generalized Random Dot Product Graphs}

\normalsize

JSM Speed Presentation

August 2022

::: columns

:::: {.column width='33%'}

```{r, out.width = '67px'}
knitr::include_graphics('john-koo.jpeg')
```

John Koo,  
PhD Student in Statistical Science,  
Indiana University

::::

:::: {.column width='33%'}

```{r, out.width = '67px'}
knitr::include_graphics('minh-tang.jpg')
```

Minh Tang,  
Assistant Professor of Statistics,  
NC State University

::::

:::: {.column width='33%'}

```{r, out.width = '67px'}
knitr::include_graphics('michael-trosset.jpg')
```

Michael Trosset,  
Professor of Statistics,  
Indiana University

::::

:::

## Community Detection for Networks

\newcommand{\diag}{\text{diag}}
\newcommand{\tr}{\text{Tr}}
\newcommand{\blockdiag}{\text{blockdiag}}
\newcommand{\indep}{\stackrel{\text{ind}}{\sim}}
\newcommand{\iid}{\stackrel{\text{iid}}{\sim}}
\newcommand{\Bernoulli}{\text{Bernoulli}}
\newcommand{\Betadist}{\text{Beta}}
\newcommand{\BG}{\text{BernoulliGraph}}
\newcommand{\Cat}{\text{Categorical}}
\newcommand{\Uniform}{\text{Uniform}}
\newcommand{\RDPG}{\text{RDPG}}
\newcommand{\GRDPG}{\text{GRDPG}}
\newcommand{\PABM}{\text{PABM}}

```{r out.width = '50%', fig.height = 3, fig.width = 4}
n <- 64
Pz <- generate.P.beta(n, 4, 4, 1, 1, 4)
P <- Pz$P
z <- Pz$clustering
A <- draw.graph(P)
qgraph::qgraph(A, groups = factor(z), legend = FALSE)
```

**Def** Popularity Adjusted Block Model (Sengupta and Chen, 2017):

Let each vertex $i \in [n]$ have $K$ popularity parameters
$\lambda_{i1}, ..., \lambda_{iK} \in [0, 1]$.  
Then $A \sim \BG(P)$ is a PABM if each 
$P_{ij} = \lambda_{i z_j} \lambda_{j z_i}$

## Popularity Adjusted Block Model

**Def** Popularity Adjusted Block Model (Sengupta and Chen, 2017):

Let each vertex $i \in [n]$ have $K$ popularity parameters
$\lambda_{i1}, ..., \lambda_{iK} \in [0, 1]$. 
Then $A \sim \PABM(\{\lambda_{ik}\}_K)$ if each $P_{ij} = \lambda_{i z_j} \lambda_{j z_i}$. 

**Def** (Noroozi, Rimal, and Pensky, 2020): 

$A$ is sampled from a PABM if $P$ can be described as:

1. Let each $P^{(kl)}$ denote the $n_k \times n_l$ matrix of edge probabilities 
between communities $k$ and $l$. 
2. Organize popularity parameters as vectors 
$\lambda^{(kl)} \in \mathbb{R}^{n_k}$ 
such that $\lambda^{(kl)}_i = \lambda_{k_i l}$ is the popularity parameter 
of the $i$^th^ vertex of community $k$ towards community $l$. 
3. Each block can be decomposed as 
$P^{(kl)} = \lambda^{(kl)} (\lambda^{(lk)})^\top$.

## Generalized Random Dot Product Graph

**Def** Generalized Random Dot Product Graph  
(Rubin-Delanchy, Cape, Tang, Priebe, 2020)

Let $I_{p,q} = \blockdiag(I_p, -I_q)$ and suppose that $x_1, \ldots, x_n \in \mathbb{R}^{p+q}$ are such that $x_i^\top I_{p,q} x_j \in [0,1]$.  
Then $A \sim \GRDPG_{p, q}(X)$ iff $A \sim \BG(X I_{p,q} X^\top)$, where $X = \begin{bmatrix} x_1 & \cdots & x_n \end{bmatrix}^\top$. 

Adjacency Spectral Embedding (Sussman et al., 2012) estimates $x_1, ..., x_n \in \mathbb{R}^{p+q}$ from $A$: 

1. Let $\hat{\Lambda}$ be the diagonal matrix that contains the absolute values of the $p$ most positive and the $q$ most negative eigenvalues.
2. Let $\hat{V}$ be the matrix whose columns are the corresponding eigenvectors.
3. Compute $\hat{X} = \hat{V} \hat{\Lambda}^{1/2}$.

**Theorem**: $\max\limits_i \|\hat{X}_i - Q_n X_i \| = O_P \Big( \frac{(\log n)^c}{n^{1/2}} \Big)$.

## Connecting Block Models to the GRDPG Model

::: columns

:::: column

```{r, out.width = '50%', fig.height = 2.5, fig.width = 2.5}
n1 <- n / 2
n2 <- n / 2
z <- c(rep(1, n1), rep(2, n2))
p <- 1/2
q <- 1/4
r <- 1/8
P <- matrix(r, nrow = n, ncol = n)
P[seq(n1), seq(n1)] <- p
P[seq(n1 + 1, n), seq(n1 + 1, n)] <- q
P.eigen = eigen(P)
X <- P.eigen$vectors[, 1:2] %*% diag(P.eigen$values[1:2] ** .5)

A.eigen <- eigen(A)
X.hat <- A.eigen$vectors[, 1:2] %*% diag(A.eigen$values[1:2] ** .5)
par(mar = rep(1.75, 4))
plot(X, asp = 1, col = z, xlab = NA, ylab = NA, main = 'SBM: Point masses')
```

\vspace*{.5\baselineskip}

```{r, out.width = '50%', fig.height = 2.5, fig.width = 2.5}
par(mar = rep(1.75, 4))
omega <- rbeta(n, 1, 1)
dc.matrix <- omega %*% t(omega)
P.dcbm <- P * dc.matrix
dcbm.eigen <- eigen(P.dcbm)
X.dcbm <- dcbm.eigen$vectors[, 1:2] %*% diag(dcbm.eigen$values[1:2] ** .5)
plot(X.dcbm, asp = 1, col = z, xlab = NA, ylab = NA, main = 'DCBM: Rays')

```

::::

:::: column

\vspace*{0\baselineskip}

```{r, out.width = '100%', fig.height = 4, fig.width = 4}
par(mar = rep(1.75, 4))
Pz <- generate.P.beta(n * 10)
P <- Pz$P
z <- Pz$clustering
X <- embedding(P, 3, 1)
pairs(X, col = z, asp = 1, pch = '.', main = 'PABM: Orthogonal subspaces')
```

::::

:::

## Connecting the PABM to the GRDPG

**Theorem** (KTT): $A \sim \PABM(\{\lambda_{ik}\}_K)$ is equivalent to 
$A \sim \GRDPG_{p, q}(X U)$ with

* $p = K (K + 1) / 2$, $q = K (K - 1) / 2$;
* $U$ is an orthogonal matrix;
* $X \in \mathbb{R}^{n \times K^2}$ is a block diagonal matrix 
composed of popularity vectors with each block corresponding to a community.  

$$X = \begin{bmatrix}
\Lambda^{(1)} & \cdots & 0 \\
0 & \ddots & 0 \\
0 & \cdots & \Lambda^{(K)}
\end{bmatrix} 
\in \mathbb{R}^{n \times K^2}$$

$$\Lambda^{(k)} = \begin{bmatrix} 
\lambda^{(k1)} & \cdots & \lambda^{(kK)} 
\end{bmatrix} 
\in \mathbb{R}^{n_k \times K}$$

$$A \sim \PABM(\{\lambda_{ik}\}_K) \text{ iff } A \sim \GRDPG_{p, q}(X U)$$

## Orthogonal Spectral Clustering

**Theorem** (KTT): 
If $P = V \Lambda V^\top$ and $B = n V V^\top$,  
then $B_{ij} = 0$ if $z_i \neq z_j$.

**Algorithm**: Orthogonal Spectral Clustering:

1. Let $V$ be the eigenvectors of $A$ corresponding to the $K (K+1)/2$ most 
positive and $K (K-1) / 2$ most negative eigenvalues.
2. Compute $B = |n V V^\top|$ applying $|\cdot|$ entry-wise.
3. Construct graph $G$ using $B$ as its similarity matrix.
4. Partition $G$ into $K$ disconnected subgraphs.

**Theorem** (KTT): 
Let $\hat{B}$ with entries $\hat{B}_{ij}$ be the affinity matrix from OSC. 
Then $\forall$ pairs $(i, j)$ belonging to different communities 
and sparsity factor satisfying $n \rho_n = \omega\big((\log n)^{4c}\big)$,  
$\max_{i, j} \hat{B}_{ij} = 
O_P \Big( \frac{(\log n)^c}{\sqrt{n \rho_n}} \Big)$.

**Corollary**: OSC results in zero clustering error as $n \to \infty$, with probability 1.

## Simulation Study

We compare four algorithms for community detection on randomly generated PABMs:  

* Modularity Maximization (Sengupta and Chen) using the Louvain algorithm;
* Orthogonal Spectral Clustering (KTT);
* Sparse Subspace Clustering on the columns of $A$  
(Noorozi, Rimal, Pensky); 
* Sparse Subspace Clustering on the ASE (KTT).

```{r, fig.height = 3, fig.width = 8, out.width = '100%'}
clustering.df <- readr::read_csv('~/dev/pabm-grdpg/simulation-results/cluster-sim-balanced.csv')

clustering.df %>%
  dplyr::group_by(n, K) %>%
  dplyr::summarise(
    med.err = median(error.osc),
    first.q = quantile(error.osc, .25),
    third.q = quantile(error.osc, .75),
    med.err.ssc = median(error.ssc.ase),
    first.q.ssc = quantile(error.ssc.ase, .25),
    third.q.ssc = quantile(error.ssc.ase, .75),
    med.err.louvain = median(error.louvain),
    first.q.louvain = quantile(error.louvain, .25),
    third.q.louvain = quantile(error.louvain, .75),
    med.err.ssc.A = median(error.ssc.A),
    first.q.ssc.A = quantile(error.ssc.A, .25),
    third.q.ssc.A = quantile(error.ssc.A, .75)
  ) %>% 
  dplyr::ungroup() %>% 
  ggplot() +
  theme_bw() + 
  theme(legend.position = 'bottom') + 
  scale_x_log10(breaks = c(128, 256, 512, 1024, 2048, 4096),
                labels = c(expression(2^7), 
                           expression(2^8), 
                           expression(2^9), 
                           expression(2^10), 
                           expression(2^11), 
                           expression(2^12))) +
  scale_y_log10() + 
  labs(y = 'community detection error count', 
       colour = NULL, shape = NULL) +
  geom_line(aes(x = n, y = med.err * n,
                colour = 'OSC')) +
  geom_point(aes(x = n, y = med.err * n,
                 colour = 'OSC', shape = 'OSC')) +
  geom_errorbar(aes(x = n, ymin = first.q * n, ymax = third.q * n,
                    colour = 'OSC'), width = .1) + 
  geom_line(aes(x = n, y = med.err.ssc * n,
                colour = 'SSC-ASE')) +
  geom_point(aes(x = n, y = med.err.ssc * n,
                 colour = 'SSC-ASE', shape = 'SSC-ASE')) +
  geom_errorbar(aes(x = n, ymin = first.q.ssc * n, ymax = third.q.ssc * n,
                    colour = 'SSC-ASE'), width = .1) +
  geom_line(aes(x = n, y = med.err.ssc.A * n,
                colour = 'SSC-A')) +
  geom_point(aes(x = n, y = med.err.ssc.A * n,
                 colour = 'SSC-A', shape = 'SSC-A')) +
  geom_errorbar(aes(x = n, ymin = first.q.ssc.A * n, ymax = third.q.ssc.A * n,
                    colour = 'SSC-A'), width = .1) +
  geom_line(aes(x = n, y = med.err.louvain * n,
                colour = 'MM-Louvain')) + 
  geom_point(aes(x = n, y = med.err.louvain * n,
                 colour = 'MM-Louvain', shape = 'MM-Louvain')) + 
  geom_errorbar(aes(x = n, ymin = first.q.louvain * n, ymax = third.q.louvain * n,
                    colour = 'MM-Louvain'), width = .1) + 
  scale_colour_brewer(palette = 'Set1') + 
  facet_wrap(~ K, labeller = 'label_both')
```

## Popularity Adjusted Block Models are Generalized Random Dot Product Graphs

Published in *Journal of Computational and Graphical Statistics*

arXiv preprint: https://arxiv.org/abs/2109.04010

GitHub repository: https://github.com/johneverettkoo/pabm-grdpg

R package: https://github.com/johneverettkoo/osc